---
slug: /tech/theory/design-pattern/simple-factory
tag: ["设计模式"]
date: 2024-01-31T19:04
---
# 工厂模式(Factory)

## 简单工厂(SimpleFactory)

**定义：** 定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类

**类型：**创建型

**类图：**

![ ](https://picgo-starry.oss-cn-beijing.aliyuncs.com/img/DesignPattern/simpleFactory.png)

**组件说明：**

- Product：工厂类所创建的所有对象的父类，封装了产品对象的公共方法，所有的具体产品为其子类对象
- Apple等：工厂创建的目标，是Product的具体类
- Factory：负责创建所有产品

**使用场景：**

- 工厂类负责创建的对象较少，因为不会造成工厂方法中的业务逻辑过于复杂
- 客户端只知道传入工厂类的参数，对如何创建对象不关心 

**优点：**

- 工厂类负责创建对象，可以决定在什么时候创建哪个对象，客户端免除创建产品对象的职责
- 客户端无需知道所创建具体产品的类名，只需知道参数就可以
- 可以引入配置文件，不修改客户端代码的前提下更换和具体产品类

**缺点：**

- 工厂类集中了所有产品类的创建，职责过重
- 使用简单工厂会增加系统中类的个数（引入新的工厂类），增加系统复杂度
- 系统扩展困难，一旦增加新产品不得不修改工厂逻辑
- 简单工厂使用了static工厂方法，造成工厂角色无法形成基于继承的等级结构

## 工厂方法(FactoryMehod)

**定义：**定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行

**类型：** 创建型

**类图：**

![image-20210510183515132](https://picgo-starry.oss-cn-beijing.aliyuncs.com/img/DesignPattern/FactoryMethod.png)

**组件说明：**

- Product：抽象产品类
- ConcreteProduct：具体的产品类
- Factory：抽象工厂，提供抽象方法供具体工厂实现
- ConcreteFactory：具体工厂类，提供具体的工厂

**使用场景：** 

- 创建对象需要大量重复代码
- 一个类通过子类来制定创建哪个对象
- 客户端不依赖于产品类实例如何被创建的细节

**优点：**

- 用户只需要关注产品的对应工厂，无需关注细节
- 加入新产品符合开闭原则，提高可扩展性

**缺点：**

- 类的个数容易过多，增加复杂度
- 增加了系统的抽象性和理解难度

## 简单工厂与工厂方法的比较

什么时候使用简单工厂，什么时候使用工厂方法

- 单个对象的创建比较复杂时，推荐使用工厂方法

比如获取建行账户信息，确认企业是否有建行账户之类的。也就是说，当你选择建行资方的时候，可以在建行工厂类当中先判断是否符合

创建建行贷款申请类的条件，然后进行相应的初始化，最后再创建建行贷款申请类
